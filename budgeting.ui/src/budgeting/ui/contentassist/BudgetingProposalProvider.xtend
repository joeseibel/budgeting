/*
 * generated by Xtext
 */
package budgeting.ui.contentassist

import budgeting.budgeting.BudgetFactorEntry
import budgeting.budgeting.Month
import budgeting.budgeting.MonthEnum
import budgeting.budgeting.Year
import budgeting.ui.contentassist.antlr.internal.InternalBudgetingLexer
import java.time.LocalDate
import org.antlr.runtime.ANTLRStringStream
import org.antlr.runtime.RecognitionException
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType
import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode

class BudgetingProposalProvider extends AbstractBudgetingProposalProvider {
	override protected doCreateIntProposals() {
		false
	}
	
	override protected doCreateIdProposals() {
		false
	}
	
	override completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {
		switch month : MonthEnum.get(keyword.value) {
			case null: super.completeKeyword(keyword, contentAssistContext, acceptor)
			default: {
				val year = contentAssistContext.currentModel.getContainerOfType(Year)
				val currentOffset = contentAssistContext.currentNode.offset
				val previousMonth = year.months.findLast[node.offset < currentOffset]?.name
				val nextMonth = year.months.findFirst[node.offset > currentOffset]?.name
				if ((previousMonth == null || month > previousMonth) && (nextMonth == null || month < nextMonth) && !year.months.exists[name == month]) {
					super.completeKeyword(keyword, contentAssistContext, acceptor)
				}
			}
		}
	}
	
	override completeLibrary_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val fileName = context.resource.URI.trimFileExtension.lastSegment
		val lexer = new InternalBudgetingLexer(new ANTLRStringStream(fileName))
		try {
			lexer.mRULE_ID
			acceptor.accept(createCompletionProposal(fileName, context))
		} catch (RecognitionException e) {
		}
	}
	
	override completeYear_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val fileName = context.resource.URI.trimFileExtension.lastSegment
		try {
			val proposalYear = Integer.parseInt(fileName)
			if (proposalYear >= 2015 && proposalYear <= java.time.Year.now.value + 1) {
				acceptor.accept(createCompletionProposal(fileName, context))
			}
		} catch (NumberFormatException e) {
		}
	}
	
	override completeBudgetEntry_Category(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val existingCategories = model.getContainerOfType(Month)?.budgetEntries?.map[category.name]?.filterNull?.toSet ?: emptySet
		lookupCrossReference(assignment.terminal as CrossReference, context, acceptor, [
			!existingCategories.contains(name.lastSegment)
		])
	}
	
	override completeActualEntry_Category(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val existingCategories = model.getContainerOfType(Month)?.actualEntries?.map[category.name]?.filterNull?.toSet ?: emptySet
		lookupCrossReference(assignment.terminal as CrossReference, context, acceptor, [
			!existingCategories.contains(name.lastSegment)
		])
	}
	
	override completeBudgetEntry_BaseEntry(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val currentCategory = model.getContainerOfType(BudgetFactorEntry)?.category?.name
		lookupCrossReference(assignment.terminal as CrossReference, context, acceptor, [
			name.lastSegment != currentCategory
		])
	}
	
	override completeTransaction_Day(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val now = LocalDate.now
		if (model.getContainerOfType(Month)?.name == now.month && model.getContainerOfType(Year).name == now.year) {
			acceptor.accept(createCompletionProposal(now.dayOfMonth.toString, context))
		}
	}
	
	def private static operator_equals(MonthEnum a, java.time.Month b) {
		(a === null && b === null) || (a !== null && b !== null && a.ordinal == b.ordinal)
	}
}