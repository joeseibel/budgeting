/*
 * generated by Xtext
 */
package budgeting.ui.contentassist

import budgeting.budgeting.MonthEnum
import budgeting.budgeting.Year
import budgeting.ui.contentassist.antlr.internal.InternalBudgetingLexer
import org.antlr.runtime.ANTLRStringStream
import org.antlr.runtime.RecognitionException
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType
import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode

class BudgetingProposalProvider extends AbstractBudgetingProposalProvider {
	override protected doCreateIntProposals() {
		false
	}
	
	override protected doCreateIdProposals() {
		false
	}
	
	override completeLibrary_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val fileName = context.resource.URI.trimFileExtension.lastSegment
		val lexer = new InternalBudgetingLexer(new ANTLRStringStream(fileName))
		try {
			lexer.mRULE_ID
			acceptor.accept(createCompletionProposal(fileName, context))
		} catch (RecognitionException e) {
		}
	}
	
	override completeYear_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val fileName = context.resource.URI.trimFileExtension.lastSegment
		try {
			val proposalYear = Integer.parseInt(fileName)
			if (proposalYear >= 2015 && proposalYear <= java.time.Year.now.value + 1) {
				acceptor.accept(createCompletionProposal(fileName, context))
			}
		} catch (NumberFormatException e) {
		}
	}
	
	override completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {
		switch month : MonthEnum.get(keyword.value) {
			case null: super.completeKeyword(keyword, contentAssistContext, acceptor)
			default: {
				val year = contentAssistContext.currentModel.getContainerOfType(Year)
				val currentOffset = contentAssistContext.currentNode.offset
				val previousMonth = year.months.findLast[node.offset < currentOffset]?.name
				val nextMonth = year.months.findFirst[node.offset > currentOffset]?.name
				if ((previousMonth == null || month.ordinal > previousMonth.ordinal) &&
					(nextMonth == null || month.ordinal < nextMonth.ordinal) && !year.months.exists[name == month]
				) {
					super.completeKeyword(keyword, contentAssistContext, acceptor)
				}
			}
		}
	}
}